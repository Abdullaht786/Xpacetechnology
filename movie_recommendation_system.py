# -*- coding: utf-8 -*-
"""Movie Recommendation System

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/movie-recommendation-system-40eab8e2-e710-443a-ad50-57d5fb38819e.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20241117/auto/storage/goog4_request%26X-Goog-Date%3D20241117T081232Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D5c4e2a48e7ff92b44f2327d77bc8670370e8bb409e62f4f3286055a80941b26e1dae88872f18d763ee8325ae614286c963672b9cc6b05d99e1334122c1c4640fc2088e8aec42339a6c45ec63cdaca2b19ade629eb615415a0205d68d48fe781ff4d1f415da7b5b9179a0d4a7733ba3f3164fd6859a7217dc1d5a58895cd4e87a0e2b0fa11a59cff193979ad480249392589d7570b32d2a2174a908d1eed5cb1071fff7d8c4a83e54cd93c3b8e5666930c8d0dbf6630463402db433586893ac7178c2b74832fa5f71c7bcf1511e46defc6d24d72e10ad80d652eb5d9dd365c1339691adf071e749fa38fa209e35daee8868e6adf6b81e539858242578511ae2f1

First, we import our neccessary libraries:
"""

import pandas as pd
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import ipywidgets as widgets
from IPython.display import display, clear_output

"""The following checks if our data has been successfully imported:"""

movies = pd.read_csv('/kaggle/input/movie-recommendation-system/movies.csv')
movies.head()

"""Here, we are pre-processing our data by dropping any irrelevant columns:"""

movies.drop(columns=['genres'], inplace=True)
movies.head()

"""We will then proceed to building our search engine. This will be done by using sk-learn, specifically TD-IDF vectorisation:"""

vectorizer = TfidfVectorizer(ngram_range=(1, 2))
tfidf = vectorizer.fit_transform(movies["title"])

"""We then also make use of cosine similarity to determine an output:"""

def search(title):
    query_vec = vectorizer.transform([title])
    similarity = cosine_similarity(query_vec, tfidf).flatten()
    indices = np.argpartition(similarity, -5)[-5:]
    results = movies.iloc[indices].iloc[::-1]

    return results

"""Finally, we make use of ipywidgets to implement our search engine as a widget:"""

movie_input = widgets.Text(
    description='Movie Title:',
    disabled=False
)
movie_list = widgets.Output()

def on_type(data):
    with movie_list:
        clear_output(wait=True)
        title = data["new"]
        if len(title) > 5:
            print(f"Searching for: {title}")
            results = search(title)
            display(results)

movie_input.observe(on_type, names='value')


display(movie_input, movie_list)

"""The following code imports our 'ratings' dataset:"""

ratings = pd.read_csv('/kaggle/input/movie-recommendation-system/ratings.csv')

"""The following code builds our recommendation system, making use of collaborative filtering and user ratings to generate a recommendation score for each individual movie:"""

def find_recs(movie_id):
    #users that liked the same movie
    similar_users = ratings[(ratings["movieId"] == movie_id) & (ratings["rating"] > 4)]["userId"].unique()

    #movies that 10% or more of similar users liked
    similar_user_recs = ratings[(ratings["userId"].isin(similar_users)) & (ratings["rating"] > 4)]["movieId"]
    similar_user_recs = similar_user_recs.value_counts() / len(similar_users)
    similar_user_recs = similar_user_recs[similar_user_recs > .10]

    #percentage of all users who rated the movies in similar_user_recs
    all_users = ratings[(ratings["movieId"].isin(similar_user_recs.index)) & (ratings["rating"] > 4)]
    all_user_recs = all_users["movieId"].value_counts() / len(all_users["userId"].unique())
    return similar_user_recs, all_user_recs

def movie_scores(movie_id):
    similar_user_recs, all_user_recs = find_recs(movie_id)
    rec_percentages = pd.concat([similar_user_recs, all_user_recs], axis=1)
    rec_percentages.columns = ["similar", "all"]

    rec_percentages["score"] = rec_percentages["similar"] / rec_percentages["all"]
    rec_percentages = rec_percentages.sort_values("score", ascending=False)
    return rec_percentages.head(10).merge(movies, left_index=True, right_on="movieId")[["score", "title"]]

"""We can then create a widget-based UI for the system:"""

movie_name_input = widgets.Text(
    description='Movie Title:',
    disabled=False
)
recommendation_list = widgets.Output()

def on_type(data):
    with recommendation_list:
        recommendation_list.clear_output()
        title = data["new"]
        if len(title) > 5:
            results = search(title)
            movie_id = results.iloc[0]["movieId"]
            display(movie_scores(movie_id))

movie_name_input.observe(on_type, names='value')

display(movie_name_input, recommendation_list)